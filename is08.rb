#[1]
def rotate(x,p,q)
	t=x[p]
	for i in p+1..q
		x[i-1]=x[i]
	end
	x[q]=t
end

#(a)
#Array#reverseは新しい部分配列を必要とするため使用できない。
def reverse(x,p,q) ((q-p)/2+1).times{|i| x[p+i],x[q-i]=x[q-i],x[p+i]}; return x end

#(b)
def transpose1(x,k) k.times{rotate(x,0,x.length-1)} end
#k回rotate()を実行しなければならないため計算量はO(kn)。

#(c)
def transpose2(x,k) reverse(x,0,k-1); reverse(x,k,x.length-1); reverse(x,0,x.length-1) end
#計算量は線形時間、O(n)となる。

#[2]
#(a) ある有限の区間を区切って、その区間内で全ての実数が同じ確率濃度で現れるような乱数
#(b) コンピュータで、ある起点からある計算を繰り返すことで発生する乱数。無理数は現れないので一様ではないし、
#繰り返すという性質上、循環が発生し、それまでに発生しなかった数は以降発生しないという点で本当の意味での乱数ではない。
#(c) 正確に求めようとすると時間がかかる問題で、それほど正確でなくて良い場合。例えば、-1から1までの乱数の二つ組を発生させて、それが単位円内に入った割合(=π/4)から円周率πを求める方法であれば有効数字5桁は短時間で確保できる。
#(d) 半径をrand()で出したのでは原点付近に密になってしまう((rcosθ,rsinθ)を、例えばθ=0°,60°,120°,180°,240°,300°として、rを0.1から1まで0.1ずつ変えてプロットすれば、θとrは一様であるのにxy座標系でのプロットは一様でないことは明確であろう)。
###極座標故の困難さである。

#[3]
def rec(a,n)
#p n
	if n==0
		0
	else
		i = 0
		k = -1
		for i in 0..a.length()-1
			if n >= a[i]
				r = rec(a,n-a[i])
				if r >= 0 && (k < 0 || r + 1 < k)
					k = r + 1
				end
			end
		end
		k
	end
end

#(a) nにより、 7->5,4 5->3,2 4->2,1 3->1,0 2->0 という呼び出しが発生する。
#0と1が葉となるので、nが、2の時2回、3の時3回、4の時4回、5の時6回、7の時11回となり、呼び出し回数は11回となる。
#(b) [2,3],7の時、2,3の順番で取るか3,2の順番で取るかと言う場合、同じことをしているにもかかわらずコンピュータ上では別の枝をたどっているため別のことと見なされてしまう。
#(c) 
def ite(a,n) #b => その数を作るのに必要な最低回数。これが読めればすべての空欄は一発で埋まる。
	b = Array.new(n+1)
	b[0] = 0
	for m in 1..n
		i = 0
		k = -1
		for i in 0..a.length()-1
			#p a[i]
			if m >= a[i] && b[m-a[i]] >= 0 && (k < 0 || b[m-a[i]] + 1 < k)
				k = b[m-a[i]] + 1
			end
		end
		b[m] = k
	end
	b[n]
end
#(d) 低い数から順にその数を作るのに必要な最低回数を求めて記録しておけば、ある数の最低回数は(その数-配列内のどれかの数)の最低回数+1とすればよいため。

#解説:
#(d) 動的計画法と言います。
#(b) 実は降順にソートしてから、{n-a[i]を割り切る要素がaに存在する時のみ再帰,見つかった時点で戻る}ようにすると重複は回避できる。
#しかも、ベンチマークの結果、
#bench(5){rec2([1,2,5,10,20,50,100,200,500,1000,2000,5000,10000],4321)} => 0.01
#bench(5){ite([1,2,5,10,20,50,100,200,500,1000,2000,5000,10000],4321)} => 0.56
#となり、rec2の方が圧倒的に速いことになる^^;
def rec2c(a,n)
#p n
	if n==0 then 0
	else
		a.length.times{|i|
			if n >= a[i] && a.find{|e|(n-a[i])%e==0}
				r = rec2c(a,n-a[i])
				if r >= 0
					return r + 1
				end
			end
		}
		return -1
	end
end
def rec2(a,n) rec2c(a.sort{|a,b| -(a<=>b)},n) end
#追伸:こいつは嘘解法です(1,5,6などで容易に撃墜できます、21=5+5+5+5+1)。重複は回避できますが貪欲が最適解とは限りません。
#追伸2:一方aの内容によっては有効ですので、問題文の見極めが肝心。

#[4]
#(a) Rubyはスクリプト言語なのでソースが存在すると言う仮定に基づけば、得点について要素を変更するときに氏名と学生証番号も変更すれば良い。
#(b) 氏名(文字列)、学生証番号(整数)、得点(整数)
#(c) (古)インスタンス変数をprivateにするならば、各変数の値を取得するメソッドが必要である。インスタンス変数がpublicならば(コンストラクタ以外の)メソッドは必要でない。
#(c) (改訂)各変数の値を取得するメソッドが必要である。ただしattr_readerを用いて宣言するならば(コンストラクタ以外の)メソッドは必要でない。
#(d) オブジェクト内の得点(得点を返す関数の値)を比較し、高い方のオブジェクトを前側に持ってくれば良い。
#(e) オブジェクトに変数を加えたときでも整列関数は変更しなくてよい。
#解説:
#(a) Cだと文字列変更にはstrcpy使わないと行けなかったり、整列関数のソースが無い場合は得点をいちいち参照しないと行けなかったり、とりあえず面倒です。
#(c) いっそクラスでなく構造体の方がメモリも節約できるし良いと思いますよ>_<コンストラクタが使えないのでいちいち代入する必要がありますが。
